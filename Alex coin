<!DOCTYPE html>
<html>
<head>
    <title>Simple Blockchain</title>
</head>
<body>
    <!-- Input field and buttons for interacting with the blockchain -->
    Input a Number:
    <input id="text">
    <button onclick="add()" id="output0">Add Blockchain</button>
    <button onclick="invalidate()" id="output1">Invalidate Blockchain</button>
    <!-- Display area for blockchain information -->
    <div id="display"><hr></div>
    <br>

    <!-- JavaScript code for blockchain implementation -->
    <script>
        // Define a Node constructor for linked list
        var Node = function(a) {
            this.next = null;
            this.prev = null;
            this.key = a;
            return this;
        }

        // Define a List constructor for linked list
        var List = function(a) {
            this.head = null;
            this.tail = null;
            this.length = 0;
            return this;
        }

        // Function to convert the linked list to a string
        List.prototype.listToString = function() {
            var str = '';
            var anode = this.head;
            while (anode != null) {
                str += anode.key + '<br>';
                anode = anode.next;
            }
            return str;
        }

        // Function to add a new node to the linked list
        List.prototype.push = function(a) {
            var node = new Node(a);
            if (this.head == null) {
                this.head = node;
                this.tail = node;
                this.length++;
                return node;
            }

            node.prev = this.tail;
            this.tail.next = node;
            this.tail = node;
            this.length++;
            return node;
        }

        // Function to remove the last node from the linked list
        List.prototype.pop = function() {
            var poppedNode = this.tail;
            if (this.head == null) {
                alert('');
                return null;
            }
            if (this.head == this.tail) {
                this.head = null;
                this.tail = null;
                this.length--;
                return poppedNode;
            }
            this.tail = this.tail.prev;
            this.tail.next = null;
            this.length--;
            return poppedNode;
        }

        // Function to get the last node in the linked list
        List.prototype.peek = function() {
            return this.tail;
        }

        // Define a Block constructor for blockchain
        class Block {
            constructor(data, previousHash = '') {
                this.data = data;
                this.previousHash = previousHash;
                this.hash = '';
            }

            // Function to calculate the hash of a block
            calculateHash() {
                return SHA1(this.previousHash + JSON.stringify(this.data)).toString();
            }
        }

        // Define a Blockchain constructor
        class Blockchain {
            constructor() {
                this.chain = new List();
                this.createGenesisBlock();
            }

            // Function to create the genesis block
            createGenesisBlock() {
                const block = new Block("Genesis Block", "0");
                block.hash = block.calculateHash();
                this.chain.push(block);
            }

            // Function to get the latest block in the blockchain
            getLatestBlock() {
                return this.chain.peek();
            }

            // Function to add a new block to the blockchain
            addBlock(amt) {
                const block = new Block(amt);
                block.previousHash = this.getLatestBlock().key.hash;
                block.hash = block.calculateHash();
                this.chain.push(block);

                // Display blockchain information on the webpage
                var outputArea = document.getElementById('display');
                outputArea.innerHTML += 'Adding block: <br>'
                outputArea.innerHTML += 'Data: ' + amt + '<br>';
                outputArea.innerHTML += 'Previous Hash: ' + block.previousHash + '<br>';
                outputArea.innerHTML += 'Hash: ' + block.hash + '<br>';
            }

            // Function to check the validity of the blockchain
            isChainValid() {
                var prev = this.chain.head.key;
                var curr = this.chain.head.next.key;
                while (curr != null && prev != null) {
                    if (curr.hash !== curr.calculateHash()) {
                        return false;
                    }
                    if (curr.previousHash !== prev.hash) {
                        return false;
                    }
                    prev = prev.next;
                    curr = curr.next;
                }
                return true;
            }
        }

        // Create a new blockchain instance
        let Alexcoin = new Blockchain();

        // Function to add a block to the blockchain and check its validity
        function add() {
            var amt = document.getElementById('text').value;
            Alexcoin.addBlock(amt);
            var valid = Alexcoin.isChainValid();
            var outputArea = document.getElementById('display');
            if (valid) {
                outputArea.innerHTML += 'Blockchain is valid<br>';
            } else {
                outputArea.innerHTML += 'Blockchain is invalid<br>';
            }
            outputArea.innerHTML += '<hr>';
        }

        // Function to invalidate the head block of the blockchain and check its validity
        function invalidate() {
            var outputArea = document.getElementById('display');
            var amt = document.getElementById('text').value;
            outputArea.innerHTML += 'Invalidating head block! Changing its data to ' + amt + '!<br>';
            var head = Alexcoin.chain.head.key;
            head.data = amt;
            head.hash = head.calculateHash();
            var valid = Alexcoin.isChainValid();
            if (valid) {
                outputArea.innerHTML += 'Blockchain is valid<br>';
            } else {
                outputArea.innerHTML += 'Blockchain is invalid<br>';
            }
        }

        // Secure Hash Algorithm SHA1SUM
        function SHA1(msg) {
            function rotate_left(n, s) {
                var t4 = (n << s) | (n >>> (32 - s));
                return t4;
            }

            function lsb_hex(val) {
                var str = "";
                var i;
                var vh;
                var vl;
                for (i = 0; i <= 6; i += 2) {
                    vh = (val >>> (i * 4 + 4)) & 0x0f;
                    vl = (val >>> (i * 4)) & 0x0f;
                    str += vh.toString(16) + vl.toString(16);
                }
                return str;
            }

            function cvt_hex(val) {
                var str = "";
                var i;
                var v;
                for (i = 7; i >= 0; i--) {
                    v = (val >>> (i * 4)) & 0x0f;
                    str += v.toString(16);
                }
                return str;
            }

            function Utf8Encode(string) {
                string = string.replace(/\r\n/g, "\n");
                var utftext = "";
                for (var n = 0; n < string.length; n++) {
                    var c = string.charCodeAt(n);
                    if (c < 128) {
                        utftext += String.fromCharCode(c);
                    } else if ((c > 127) && (c < 2048)) {
                        utftext += String.fromCharCode((c >> 6) | 192);
                        utftext += String.fromCharCode((c & 63) | 128);
                    } else {
                        utftext += String.fromCharCode((c >> 12) | 224);
                        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                        utftext += String.fromCharCode((c & 63) | 128);
                    }
                }
                return utftext;
            }

            var blockstart;
            var i, j;
            var W = new Array(80);
            var H0 = 0x67452301;
            var H1 = 0xEFCDAB89;
            var H2 = 0x98BADCFE;
            var H3 = 0x10325476;
            var H4 = 0xC3D2E1F0;
            var A, B, C, D, E;
            var temp;
            msg = Utf8Encode(msg);
            var msg_len = msg.length;
            var word_array = new Array();
            for (i = 0; i < msg_len - 3; i += 4) {
                j = msg.charCodeAt(i) << 24 | msg.charCodeAt(i + 1) << 16 |
                    msg.charCodeAt(i + 2) << 8 | msg.charCodeAt(i + 3);
                word_array.push(j);
            }

            switch (msg_len % 4) {
                case 0:
                    i = 0x080000000;
                    break;
                case 1:
                    i = msg.charCodeAt(msg_len - 1) << 24 | 0x0800000;
                    break;
                case 2:
                    i = msg.charCodeAt(msg_len - 2) << 24 | msg.charCodeAt(msg_len - 1) << 16 | 0x08000;
                    break;
                case 3:
                    i = msg.charCodeAt(msg_len - 3) << 24 | msg.charCodeAt(msg_len - 2) << 16 | msg.charCodeAt(msg_len - 1) << 8 | 0x80;
                    break;
            }

            word_array.push(i);
            while ((word_array.length % 16) != 14) word_array.push(0);
            word_array.push(msg_len >>> 29);
            word_array.push((msg_len << 3) & 0x0ffffffff);
            for (blockstart = 0; blockstart < word_array.length; blockstart += 16) {
                for (i = 0; i < 16; i++) W[i] = word_array[blockstart + i];
                for (i = 16; i <= 79; i++) W[i] = rotate_left(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
                A = H0;
                B = H1;
                C = H2;
                D = H3;
                E = H4;
                for (i = 0; i <= 19; i++) {
                    temp = (rotate_left(A, 5) + ((B & C) | (~B & D)) + E + W[i] + 0x5A827999) & 0x0ffffffff;
                    E = D;
                    D = C;
                    C = rotate_left(B, 30);
                    B = A;
                    A = temp;
                }

                for (i = 20; i <= 39; i++) {
                    temp = (rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 0x6ED9EVA1) & 0x0ffffffff;
                    E = D;
                    D = C;
                    C = rotate_left(B, 30);
                    B = A;
                    A = temp;
                }

                for (i = 40; i <= 59; i++) {
                    temp = (rotate_left(A, 5) + ((B & C) | (B & D) | (C & D)) + E + W[i] + 0x8F1BBCDC) & 0x0ffffffff;
                    E = D;
                    D = C;
                    C = rotate_left(B, 30);
                    B = A;
                    A = temp;
                }

                for (i = 60; i <= 79; i++) {
                    temp = (rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 0xCA62C1D6) & 0x0ffffffff;
                    E = D;
                    D = C;
                    C = rotate_left(B, 30);
                    B = A;
                    A = temp;
                }
                H0 = (H0 + A) & 0x0ffffffff;
                H1 = (H1 + B) & 0x0ffffffff;
                H2 = (H2 + C) & 0x0ffffffff;
                H3 = (H3 + D) & 0x0ffffffff;
                H4 = (H4 + E) & 0x0ffffffff;
            }
            var temp = cvt_hex(H0) + cvt_hex(H1) + cvt_hex(H2) + cvt_hex(H3) + cvt_hex(H4);
            return temp.toLowerCase();
        }
    </script>
</body>
</html>
